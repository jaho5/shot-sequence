{"ast":null,"code":"const HORIZONTAL_POSITIONS = ['Left', 'Center Left', 'Center', 'Center Right', 'Right'];\nconst DEPTH_POSITIONS = ['Back', 'Mid Back', 'Mid', 'Mid Front', 'Front'];\nexport const generateRandomShot = space => {\n  const randomHorizontal = HORIZONTAL_POSITIONS[Math.floor(Math.random() * HORIZONTAL_POSITIONS.length)];\n  const randomDepth = DEPTH_POSITIONS[Math.floor(Math.random() * DEPTH_POSITIONS.length)];\n  return {\n    horizontal: randomHorizontal,\n    depth: randomDepth,\n    space: space\n  };\n};\nexport const generateShotSequence = numShots => {\n  const shots = [];\n  for (let i = 0; i < numShots; i++) {\n    const space = i % 2 + 1; // Alternates between 1 and 2\n    shots.push(generateRandomShot(space));\n  }\n  return shots;\n};\nexport const getPositionCoordinates = (horizontal, depth) => {\n  const horizontalIndex = HORIZONTAL_POSITIONS.indexOf(horizontal);\n  const depthIndex = DEPTH_POSITIONS.indexOf(depth);\n\n  // Convert to grid coordinates (0-4 for both x and y)\n  return {\n    x: horizontalIndex,\n    y: depthIndex\n  };\n};\nconst getContinuousCoordinates = shot => {\n  const baseCoords = getPositionCoordinates(shot.horizontal, shot.depth);\n  if (shot.space === 1) {\n    // Space 1: x=0-4, y=0-4 (Back=0, Front=4)\n    return {\n      x: baseCoords.x,\n      y: baseCoords.y\n    };\n  } else {\n    // Space 2: x=0-4, y=5-9 (Front=5, Back=9)\n    // Front of Space 2 connects to Front of Space 1\n    return {\n      x: baseCoords.x,\n      y: 9 - baseCoords.y // Flip and offset: Back(0)→9, Front(4)→5\n    };\n  }\n};\nconst calculateDistance = (shot1, shot2) => {\n  const coords1 = getContinuousCoordinates(shot1);\n  const coords2 = getContinuousCoordinates(shot2);\n\n  // Euclidean distance in continuous field\n  const dx = coords1.x - coords2.x;\n  const dy = coords1.y - coords2.y;\n  return Math.sqrt(dx * dx + dy * dy);\n};\nconst isValidDistance = (shot1, shot2, minDistance, maxDistance) => {\n  const distance = calculateDistance(shot1, shot2);\n  return distance >= minDistance && distance <= maxDistance;\n};\nconst getValidShotsWithinDistance = (previousShot, targetSpace, minDistance, maxDistance) => {\n  const validShots = [];\n\n  // Check all possible positions in the target space\n  for (const horizontal of HORIZONTAL_POSITIONS) {\n    for (const depth of DEPTH_POSITIONS) {\n      const candidateShot = {\n        horizontal,\n        depth,\n        space: targetSpace\n      };\n      const distance = calculateDistance(previousShot, candidateShot);\n      if (distance >= minDistance && distance <= maxDistance) {\n        validShots.push(candidateShot);\n      }\n    }\n  }\n  return validShots;\n};\nexport const generateShotSequenceWithDistance = (numShots, minDistance = 0, maxDistance = Infinity) => {\n  const shots = [];\n  for (let i = 0; i < numShots; i++) {\n    const space = i % 2 + 1;\n\n    // For the first shot, no distance constraint needed\n    if (i === 0) {\n      shots.push(generateRandomShot(space));\n    } else {\n      // Get all valid shots within distance constraints\n      const validShots = getValidShotsWithinDistance(shots[i - 1], space, minDistance, maxDistance);\n\n      // If no valid shots exist, return null to indicate failure\n      if (validShots.length === 0) {\n        return null;\n      }\n\n      // Randomly select from valid shots\n      const randomIndex = Math.floor(Math.random() * validShots.length);\n      shots.push(validShots[randomIndex]);\n    }\n  }\n  return shots;\n};\nexport { HORIZONTAL_POSITIONS, DEPTH_POSITIONS, calculateDistance, getContinuousCoordinates };","map":{"version":3,"names":["HORIZONTAL_POSITIONS","DEPTH_POSITIONS","generateRandomShot","space","randomHorizontal","Math","floor","random","length","randomDepth","horizontal","depth","generateShotSequence","numShots","shots","i","push","getPositionCoordinates","horizontalIndex","indexOf","depthIndex","x","y","getContinuousCoordinates","shot","baseCoords","calculateDistance","shot1","shot2","coords1","coords2","dx","dy","sqrt","isValidDistance","minDistance","maxDistance","distance","getValidShotsWithinDistance","previousShot","targetSpace","validShots","candidateShot","generateShotSequenceWithDistance","Infinity","randomIndex"],"sources":["/home/jasonho/projects/shot-sequence/src/utils/shotGenerators.js"],"sourcesContent":["const HORIZONTAL_POSITIONS = ['Left', 'Center Left', 'Center', 'Center Right', 'Right'];\nconst DEPTH_POSITIONS = ['Back', 'Mid Back', 'Mid', 'Mid Front', 'Front'];\n\nexport const generateRandomShot = (space) => {\n  const randomHorizontal = HORIZONTAL_POSITIONS[Math.floor(Math.random() * HORIZONTAL_POSITIONS.length)];\n  const randomDepth = DEPTH_POSITIONS[Math.floor(Math.random() * DEPTH_POSITIONS.length)];\n  \n  return {\n    horizontal: randomHorizontal,\n    depth: randomDepth,\n    space: space\n  };\n};\n\nexport const generateShotSequence = (numShots) => {\n  const shots = [];\n  \n  for (let i = 0; i < numShots; i++) {\n    const space = (i % 2) + 1; // Alternates between 1 and 2\n    shots.push(generateRandomShot(space));\n  }\n  \n  return shots;\n};\n\nexport const getPositionCoordinates = (horizontal, depth) => {\n  const horizontalIndex = HORIZONTAL_POSITIONS.indexOf(horizontal);\n  const depthIndex = DEPTH_POSITIONS.indexOf(depth);\n  \n  // Convert to grid coordinates (0-4 for both x and y)\n  return {\n    x: horizontalIndex,\n    y: depthIndex\n  };\n};\n\nconst getContinuousCoordinates = (shot) => {\n  const baseCoords = getPositionCoordinates(shot.horizontal, shot.depth);\n  \n  if (shot.space === 1) {\n    // Space 1: x=0-4, y=0-4 (Back=0, Front=4)\n    return {\n      x: baseCoords.x,\n      y: baseCoords.y\n    };\n  } else {\n    // Space 2: x=0-4, y=5-9 (Front=5, Back=9)\n    // Front of Space 2 connects to Front of Space 1\n    return {\n      x: baseCoords.x,\n      y: 9 - baseCoords.y  // Flip and offset: Back(0)→9, Front(4)→5\n    };\n  }\n};\n\nconst calculateDistance = (shot1, shot2) => {\n  const coords1 = getContinuousCoordinates(shot1);\n  const coords2 = getContinuousCoordinates(shot2);\n  \n  // Euclidean distance in continuous field\n  const dx = coords1.x - coords2.x;\n  const dy = coords1.y - coords2.y;\n  return Math.sqrt(dx * dx + dy * dy);\n};\n\nconst isValidDistance = (shot1, shot2, minDistance, maxDistance) => {\n  const distance = calculateDistance(shot1, shot2);\n  return distance >= minDistance && distance <= maxDistance;\n};\n\nconst getValidShotsWithinDistance = (previousShot, targetSpace, minDistance, maxDistance) => {\n  const validShots = [];\n  \n  // Check all possible positions in the target space\n  for (const horizontal of HORIZONTAL_POSITIONS) {\n    for (const depth of DEPTH_POSITIONS) {\n      const candidateShot = { horizontal, depth, space: targetSpace };\n      const distance = calculateDistance(previousShot, candidateShot);\n      \n      if (distance >= minDistance && distance <= maxDistance) {\n        validShots.push(candidateShot);\n      }\n    }\n  }\n  \n  return validShots;\n};\n\nexport const generateShotSequenceWithDistance = (numShots, minDistance = 0, maxDistance = Infinity) => {\n  const shots = [];\n  \n  for (let i = 0; i < numShots; i++) {\n    const space = (i % 2) + 1;\n    \n    // For the first shot, no distance constraint needed\n    if (i === 0) {\n      shots.push(generateRandomShot(space));\n    } else {\n      // Get all valid shots within distance constraints\n      const validShots = getValidShotsWithinDistance(shots[i - 1], space, minDistance, maxDistance);\n      \n      // If no valid shots exist, return null to indicate failure\n      if (validShots.length === 0) {\n        return null;\n      }\n      \n      // Randomly select from valid shots\n      const randomIndex = Math.floor(Math.random() * validShots.length);\n      shots.push(validShots[randomIndex]);\n    }\n  }\n  \n  return shots;\n};\n\nexport { HORIZONTAL_POSITIONS, DEPTH_POSITIONS, calculateDistance, getContinuousCoordinates };"],"mappings":"AAAA,MAAMA,oBAAoB,GAAG,CAAC,MAAM,EAAE,aAAa,EAAE,QAAQ,EAAE,cAAc,EAAE,OAAO,CAAC;AACvF,MAAMC,eAAe,GAAG,CAAC,MAAM,EAAE,UAAU,EAAE,KAAK,EAAE,WAAW,EAAE,OAAO,CAAC;AAEzE,OAAO,MAAMC,kBAAkB,GAAIC,KAAK,IAAK;EAC3C,MAAMC,gBAAgB,GAAGJ,oBAAoB,CAACK,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAGP,oBAAoB,CAACQ,MAAM,CAAC,CAAC;EACtG,MAAMC,WAAW,GAAGR,eAAe,CAACI,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAGN,eAAe,CAACO,MAAM,CAAC,CAAC;EAEvF,OAAO;IACLE,UAAU,EAAEN,gBAAgB;IAC5BO,KAAK,EAAEF,WAAW;IAClBN,KAAK,EAAEA;EACT,CAAC;AACH,CAAC;AAED,OAAO,MAAMS,oBAAoB,GAAIC,QAAQ,IAAK;EAChD,MAAMC,KAAK,GAAG,EAAE;EAEhB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,QAAQ,EAAEE,CAAC,EAAE,EAAE;IACjC,MAAMZ,KAAK,GAAIY,CAAC,GAAG,CAAC,GAAI,CAAC,CAAC,CAAC;IAC3BD,KAAK,CAACE,IAAI,CAACd,kBAAkB,CAACC,KAAK,CAAC,CAAC;EACvC;EAEA,OAAOW,KAAK;AACd,CAAC;AAED,OAAO,MAAMG,sBAAsB,GAAGA,CAACP,UAAU,EAAEC,KAAK,KAAK;EAC3D,MAAMO,eAAe,GAAGlB,oBAAoB,CAACmB,OAAO,CAACT,UAAU,CAAC;EAChE,MAAMU,UAAU,GAAGnB,eAAe,CAACkB,OAAO,CAACR,KAAK,CAAC;;EAEjD;EACA,OAAO;IACLU,CAAC,EAAEH,eAAe;IAClBI,CAAC,EAAEF;EACL,CAAC;AACH,CAAC;AAED,MAAMG,wBAAwB,GAAIC,IAAI,IAAK;EACzC,MAAMC,UAAU,GAAGR,sBAAsB,CAACO,IAAI,CAACd,UAAU,EAAEc,IAAI,CAACb,KAAK,CAAC;EAEtE,IAAIa,IAAI,CAACrB,KAAK,KAAK,CAAC,EAAE;IACpB;IACA,OAAO;MACLkB,CAAC,EAAEI,UAAU,CAACJ,CAAC;MACfC,CAAC,EAAEG,UAAU,CAACH;IAChB,CAAC;EACH,CAAC,MAAM;IACL;IACA;IACA,OAAO;MACLD,CAAC,EAAEI,UAAU,CAACJ,CAAC;MACfC,CAAC,EAAE,CAAC,GAAGG,UAAU,CAACH,CAAC,CAAE;IACvB,CAAC;EACH;AACF,CAAC;AAED,MAAMI,iBAAiB,GAAGA,CAACC,KAAK,EAAEC,KAAK,KAAK;EAC1C,MAAMC,OAAO,GAAGN,wBAAwB,CAACI,KAAK,CAAC;EAC/C,MAAMG,OAAO,GAAGP,wBAAwB,CAACK,KAAK,CAAC;;EAE/C;EACA,MAAMG,EAAE,GAAGF,OAAO,CAACR,CAAC,GAAGS,OAAO,CAACT,CAAC;EAChC,MAAMW,EAAE,GAAGH,OAAO,CAACP,CAAC,GAAGQ,OAAO,CAACR,CAAC;EAChC,OAAOjB,IAAI,CAAC4B,IAAI,CAACF,EAAE,GAAGA,EAAE,GAAGC,EAAE,GAAGA,EAAE,CAAC;AACrC,CAAC;AAED,MAAME,eAAe,GAAGA,CAACP,KAAK,EAAEC,KAAK,EAAEO,WAAW,EAAEC,WAAW,KAAK;EAClE,MAAMC,QAAQ,GAAGX,iBAAiB,CAACC,KAAK,EAAEC,KAAK,CAAC;EAChD,OAAOS,QAAQ,IAAIF,WAAW,IAAIE,QAAQ,IAAID,WAAW;AAC3D,CAAC;AAED,MAAME,2BAA2B,GAAGA,CAACC,YAAY,EAAEC,WAAW,EAAEL,WAAW,EAAEC,WAAW,KAAK;EAC3F,MAAMK,UAAU,GAAG,EAAE;;EAErB;EACA,KAAK,MAAM/B,UAAU,IAAIV,oBAAoB,EAAE;IAC7C,KAAK,MAAMW,KAAK,IAAIV,eAAe,EAAE;MACnC,MAAMyC,aAAa,GAAG;QAAEhC,UAAU;QAAEC,KAAK;QAAER,KAAK,EAAEqC;MAAY,CAAC;MAC/D,MAAMH,QAAQ,GAAGX,iBAAiB,CAACa,YAAY,EAAEG,aAAa,CAAC;MAE/D,IAAIL,QAAQ,IAAIF,WAAW,IAAIE,QAAQ,IAAID,WAAW,EAAE;QACtDK,UAAU,CAACzB,IAAI,CAAC0B,aAAa,CAAC;MAChC;IACF;EACF;EAEA,OAAOD,UAAU;AACnB,CAAC;AAED,OAAO,MAAME,gCAAgC,GAAGA,CAAC9B,QAAQ,EAAEsB,WAAW,GAAG,CAAC,EAAEC,WAAW,GAAGQ,QAAQ,KAAK;EACrG,MAAM9B,KAAK,GAAG,EAAE;EAEhB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,QAAQ,EAAEE,CAAC,EAAE,EAAE;IACjC,MAAMZ,KAAK,GAAIY,CAAC,GAAG,CAAC,GAAI,CAAC;;IAEzB;IACA,IAAIA,CAAC,KAAK,CAAC,EAAE;MACXD,KAAK,CAACE,IAAI,CAACd,kBAAkB,CAACC,KAAK,CAAC,CAAC;IACvC,CAAC,MAAM;MACL;MACA,MAAMsC,UAAU,GAAGH,2BAA2B,CAACxB,KAAK,CAACC,CAAC,GAAG,CAAC,CAAC,EAAEZ,KAAK,EAAEgC,WAAW,EAAEC,WAAW,CAAC;;MAE7F;MACA,IAAIK,UAAU,CAACjC,MAAM,KAAK,CAAC,EAAE;QAC3B,OAAO,IAAI;MACb;;MAEA;MACA,MAAMqC,WAAW,GAAGxC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAGkC,UAAU,CAACjC,MAAM,CAAC;MACjEM,KAAK,CAACE,IAAI,CAACyB,UAAU,CAACI,WAAW,CAAC,CAAC;IACrC;EACF;EAEA,OAAO/B,KAAK;AACd,CAAC;AAED,SAASd,oBAAoB,EAAEC,eAAe,EAAEyB,iBAAiB,EAAEH,wBAAwB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}