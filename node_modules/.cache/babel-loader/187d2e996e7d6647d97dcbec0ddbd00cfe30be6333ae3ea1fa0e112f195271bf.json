{"ast":null,"code":"const HORIZONTAL_POSITIONS = ['Left', 'Center Left', 'Center', 'Center Right', 'Right'];\nconst DEPTH_POSITIONS = ['Back', 'Mid Back', 'Mid', 'Mid Front', 'Front'];\nexport const generateRandomShot = space => {\n  const randomHorizontal = HORIZONTAL_POSITIONS[Math.floor(Math.random() * HORIZONTAL_POSITIONS.length)];\n  const randomDepth = DEPTH_POSITIONS[Math.floor(Math.random() * DEPTH_POSITIONS.length)];\n  return {\n    horizontal: randomHorizontal,\n    depth: randomDepth,\n    space: space\n  };\n};\nexport const generateShotSequence = numShots => {\n  const shots = [];\n  for (let i = 0; i < numShots; i++) {\n    const space = i % 2 + 1; // Alternates between 1 and 2\n    shots.push(generateRandomShot(space));\n  }\n  return shots;\n};\nexport const getPositionCoordinates = (horizontal, depth) => {\n  const horizontalIndex = HORIZONTAL_POSITIONS.indexOf(horizontal);\n  const depthIndex = DEPTH_POSITIONS.indexOf(depth);\n\n  // Convert to grid coordinates (0-4 for both x and y)\n  return {\n    x: horizontalIndex,\n    y: depthIndex\n  };\n};\nconst calculateDistance = (shot1, shot2) => {\n  const coords1 = getPositionCoordinates(shot1.horizontal, shot1.depth);\n  const coords2 = getPositionCoordinates(shot2.horizontal, shot2.depth);\n\n  // Euclidean distance in grid units\n  const dx = coords1.x - coords2.x;\n  const dy = coords1.y - coords2.y;\n  return Math.sqrt(dx * dx + dy * dy);\n};\nconst isValidDistance = (shot1, shot2, minDistance, maxDistance) => {\n  const distance = calculateDistance(shot1, shot2);\n  return distance >= minDistance && distance <= maxDistance;\n};\nexport const generateShotSequenceWithDistance = (numShots, minDistance = 0, maxDistance = Infinity) => {\n  const shots = [];\n  const maxAttempts = 1000; // Prevent infinite loops\n\n  for (let i = 0; i < numShots; i++) {\n    const space = i % 2 + 1;\n    let newShot = null;\n    let attempts = 0;\n\n    // For the first shot, no distance constraint needed\n    if (i === 0) {\n      newShot = generateRandomShot(space);\n    } else {\n      // Find a shot that satisfies distance constraints from the previous shot\n      while (attempts < maxAttempts) {\n        const candidateShot = generateRandomShot(space);\n        const previousShot = shots[i - 1];\n        if (isValidDistance(candidateShot, previousShot, minDistance, maxDistance)) {\n          newShot = candidateShot;\n          break;\n        }\n        attempts++;\n      }\n\n      // If we couldn't find a valid shot, return null to indicate failure\n      if (!newShot) {\n        return null;\n      }\n    }\n    shots.push(newShot);\n  }\n  return shots;\n};\nexport { HORIZONTAL_POSITIONS, DEPTH_POSITIONS, calculateDistance };","map":{"version":3,"names":["HORIZONTAL_POSITIONS","DEPTH_POSITIONS","generateRandomShot","space","randomHorizontal","Math","floor","random","length","randomDepth","horizontal","depth","generateShotSequence","numShots","shots","i","push","getPositionCoordinates","horizontalIndex","indexOf","depthIndex","x","y","calculateDistance","shot1","shot2","coords1","coords2","dx","dy","sqrt","isValidDistance","minDistance","maxDistance","distance","generateShotSequenceWithDistance","Infinity","maxAttempts","newShot","attempts","candidateShot","previousShot"],"sources":["/home/jasonho/projects/shot-sequence/src/utils/shotGenerators.js"],"sourcesContent":["const HORIZONTAL_POSITIONS = ['Left', 'Center Left', 'Center', 'Center Right', 'Right'];\nconst DEPTH_POSITIONS = ['Back', 'Mid Back', 'Mid', 'Mid Front', 'Front'];\n\nexport const generateRandomShot = (space) => {\n  const randomHorizontal = HORIZONTAL_POSITIONS[Math.floor(Math.random() * HORIZONTAL_POSITIONS.length)];\n  const randomDepth = DEPTH_POSITIONS[Math.floor(Math.random() * DEPTH_POSITIONS.length)];\n  \n  return {\n    horizontal: randomHorizontal,\n    depth: randomDepth,\n    space: space\n  };\n};\n\nexport const generateShotSequence = (numShots) => {\n  const shots = [];\n  \n  for (let i = 0; i < numShots; i++) {\n    const space = (i % 2) + 1; // Alternates between 1 and 2\n    shots.push(generateRandomShot(space));\n  }\n  \n  return shots;\n};\n\nexport const getPositionCoordinates = (horizontal, depth) => {\n  const horizontalIndex = HORIZONTAL_POSITIONS.indexOf(horizontal);\n  const depthIndex = DEPTH_POSITIONS.indexOf(depth);\n  \n  // Convert to grid coordinates (0-4 for both x and y)\n  return {\n    x: horizontalIndex,\n    y: depthIndex\n  };\n};\n\nconst calculateDistance = (shot1, shot2) => {\n  const coords1 = getPositionCoordinates(shot1.horizontal, shot1.depth);\n  const coords2 = getPositionCoordinates(shot2.horizontal, shot2.depth);\n  \n  // Euclidean distance in grid units\n  const dx = coords1.x - coords2.x;\n  const dy = coords1.y - coords2.y;\n  return Math.sqrt(dx * dx + dy * dy);\n};\n\nconst isValidDistance = (shot1, shot2, minDistance, maxDistance) => {\n  const distance = calculateDistance(shot1, shot2);\n  return distance >= minDistance && distance <= maxDistance;\n};\n\nexport const generateShotSequenceWithDistance = (numShots, minDistance = 0, maxDistance = Infinity) => {\n  const shots = [];\n  const maxAttempts = 1000; // Prevent infinite loops\n  \n  for (let i = 0; i < numShots; i++) {\n    const space = (i % 2) + 1;\n    let newShot = null;\n    let attempts = 0;\n    \n    // For the first shot, no distance constraint needed\n    if (i === 0) {\n      newShot = generateRandomShot(space);\n    } else {\n      // Find a shot that satisfies distance constraints from the previous shot\n      while (attempts < maxAttempts) {\n        const candidateShot = generateRandomShot(space);\n        const previousShot = shots[i - 1];\n        \n        if (isValidDistance(candidateShot, previousShot, minDistance, maxDistance)) {\n          newShot = candidateShot;\n          break;\n        }\n        attempts++;\n      }\n      \n      // If we couldn't find a valid shot, return null to indicate failure\n      if (!newShot) {\n        return null;\n      }\n    }\n    \n    shots.push(newShot);\n  }\n  \n  return shots;\n};\n\nexport { HORIZONTAL_POSITIONS, DEPTH_POSITIONS, calculateDistance };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}