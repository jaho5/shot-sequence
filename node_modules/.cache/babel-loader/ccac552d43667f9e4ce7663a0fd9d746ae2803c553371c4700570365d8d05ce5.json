{"ast":null,"code":"const HORIZONTAL_POSITIONS = ['Left', 'Center Left', 'Center', 'Center Right', 'Right'];\nconst DEPTH_POSITIONS = ['Back', 'Mid Back', 'Mid', 'Mid Front', 'Front'];\nexport const generateRandomShot = space => {\n  const randomHorizontal = HORIZONTAL_POSITIONS[Math.floor(Math.random() * HORIZONTAL_POSITIONS.length)];\n  const randomDepth = DEPTH_POSITIONS[Math.floor(Math.random() * DEPTH_POSITIONS.length)];\n  return {\n    horizontal: randomHorizontal,\n    depth: randomDepth,\n    space: space\n  };\n};\nexport const generateShotSequence = numShots => {\n  const shots = [];\n  for (let i = 0; i < numShots; i++) {\n    const space = i % 2 + 1; // Alternates between 1 and 2\n    shots.push(generateRandomShot(space));\n  }\n  return shots;\n};\nexport const getPositionCoordinates = (horizontal, depth) => {\n  const horizontalIndex = HORIZONTAL_POSITIONS.indexOf(horizontal);\n  const depthIndex = DEPTH_POSITIONS.indexOf(depth);\n\n  // Convert to grid coordinates (0-4 for both x and y)\n  return {\n    x: horizontalIndex,\n    y: depthIndex\n  };\n};\nconst getContinuousCoordinates = shot => {\n  const baseCoords = getPositionCoordinates(shot.horizontal, shot.depth);\n  if (shot.space === 1) {\n    // Space 1: x=0-4, y=0-4 (Back=0, Front=4)\n    return {\n      x: baseCoords.x,\n      y: baseCoords.y\n    };\n  } else {\n    // Space 2: x=0-4, y=5-9 (Front=5, Back=9)\n    // Front of Space 2 connects to Front of Space 1\n    return {\n      x: baseCoords.x,\n      y: 9 - baseCoords.y // Flip and offset: Back(0)→9, Front(4)→5\n    };\n  }\n};\nconst calculateDistance = (shot1, shot2) => {\n  const coords1 = getContinuousCoordinates(shot1);\n  const coords2 = getContinuousCoordinates(shot2);\n\n  // Euclidean distance in continuous field\n  const dx = coords1.x - coords2.x;\n  const dy = coords1.y - coords2.y;\n  return Math.sqrt(dx * dx + dy * dy);\n};\nconst isValidDistance = (shot1, shot2, minDistance, maxDistance) => {\n  const distance = calculateDistance(shot1, shot2);\n  return distance >= minDistance && distance <= maxDistance;\n};\nexport const generateShotSequenceWithDistance = (numShots, minDistance = 0, maxDistance = Infinity) => {\n  const shots = [];\n  const maxAttempts = 1000; // Prevent infinite loops\n\n  for (let i = 0; i < numShots; i++) {\n    const space = i % 2 + 1;\n    let newShot = null;\n    let attempts = 0;\n\n    // For the first shot, no distance constraint needed\n    if (i === 0) {\n      newShot = generateRandomShot(space);\n    } else {\n      // Find a shot that satisfies distance constraints from the previous shot\n      while (attempts < maxAttempts) {\n        const candidateShot = generateRandomShot(space);\n        const previousShot = shots[i - 1];\n        if (isValidDistance(candidateShot, previousShot, minDistance, maxDistance)) {\n          newShot = candidateShot;\n          break;\n        }\n        attempts++;\n      }\n\n      // If we couldn't find a valid shot, return null to indicate failure\n      if (!newShot) {\n        return null;\n      }\n    }\n    shots.push(newShot);\n  }\n  return shots;\n};\nexport { HORIZONTAL_POSITIONS, DEPTH_POSITIONS, calculateDistance };","map":{"version":3,"names":["HORIZONTAL_POSITIONS","DEPTH_POSITIONS","generateRandomShot","space","randomHorizontal","Math","floor","random","length","randomDepth","horizontal","depth","generateShotSequence","numShots","shots","i","push","getPositionCoordinates","horizontalIndex","indexOf","depthIndex","x","y","getContinuousCoordinates","shot","baseCoords","calculateDistance","shot1","shot2","coords1","coords2","dx","dy","sqrt","isValidDistance","minDistance","maxDistance","distance","generateShotSequenceWithDistance","Infinity","maxAttempts","newShot","attempts","candidateShot","previousShot"],"sources":["/home/jasonho/projects/shot-sequence/src/utils/shotGenerators.js"],"sourcesContent":["const HORIZONTAL_POSITIONS = ['Left', 'Center Left', 'Center', 'Center Right', 'Right'];\nconst DEPTH_POSITIONS = ['Back', 'Mid Back', 'Mid', 'Mid Front', 'Front'];\n\nexport const generateRandomShot = (space) => {\n  const randomHorizontal = HORIZONTAL_POSITIONS[Math.floor(Math.random() * HORIZONTAL_POSITIONS.length)];\n  const randomDepth = DEPTH_POSITIONS[Math.floor(Math.random() * DEPTH_POSITIONS.length)];\n  \n  return {\n    horizontal: randomHorizontal,\n    depth: randomDepth,\n    space: space\n  };\n};\n\nexport const generateShotSequence = (numShots) => {\n  const shots = [];\n  \n  for (let i = 0; i < numShots; i++) {\n    const space = (i % 2) + 1; // Alternates between 1 and 2\n    shots.push(generateRandomShot(space));\n  }\n  \n  return shots;\n};\n\nexport const getPositionCoordinates = (horizontal, depth) => {\n  const horizontalIndex = HORIZONTAL_POSITIONS.indexOf(horizontal);\n  const depthIndex = DEPTH_POSITIONS.indexOf(depth);\n  \n  // Convert to grid coordinates (0-4 for both x and y)\n  return {\n    x: horizontalIndex,\n    y: depthIndex\n  };\n};\n\nconst getContinuousCoordinates = (shot) => {\n  const baseCoords = getPositionCoordinates(shot.horizontal, shot.depth);\n  \n  if (shot.space === 1) {\n    // Space 1: x=0-4, y=0-4 (Back=0, Front=4)\n    return {\n      x: baseCoords.x,\n      y: baseCoords.y\n    };\n  } else {\n    // Space 2: x=0-4, y=5-9 (Front=5, Back=9)\n    // Front of Space 2 connects to Front of Space 1\n    return {\n      x: baseCoords.x,\n      y: 9 - baseCoords.y  // Flip and offset: Back(0)→9, Front(4)→5\n    };\n  }\n};\n\nconst calculateDistance = (shot1, shot2) => {\n  const coords1 = getContinuousCoordinates(shot1);\n  const coords2 = getContinuousCoordinates(shot2);\n  \n  // Euclidean distance in continuous field\n  const dx = coords1.x - coords2.x;\n  const dy = coords1.y - coords2.y;\n  return Math.sqrt(dx * dx + dy * dy);\n};\n\nconst isValidDistance = (shot1, shot2, minDistance, maxDistance) => {\n  const distance = calculateDistance(shot1, shot2);\n  return distance >= minDistance && distance <= maxDistance;\n};\n\nexport const generateShotSequenceWithDistance = (numShots, minDistance = 0, maxDistance = Infinity) => {\n  const shots = [];\n  const maxAttempts = 1000; // Prevent infinite loops\n  \n  for (let i = 0; i < numShots; i++) {\n    const space = (i % 2) + 1;\n    let newShot = null;\n    let attempts = 0;\n    \n    // For the first shot, no distance constraint needed\n    if (i === 0) {\n      newShot = generateRandomShot(space);\n    } else {\n      // Find a shot that satisfies distance constraints from the previous shot\n      while (attempts < maxAttempts) {\n        const candidateShot = generateRandomShot(space);\n        const previousShot = shots[i - 1];\n        \n        if (isValidDistance(candidateShot, previousShot, minDistance, maxDistance)) {\n          newShot = candidateShot;\n          break;\n        }\n        attempts++;\n      }\n      \n      // If we couldn't find a valid shot, return null to indicate failure\n      if (!newShot) {\n        return null;\n      }\n    }\n    \n    shots.push(newShot);\n  }\n  \n  return shots;\n};\n\nexport { HORIZONTAL_POSITIONS, DEPTH_POSITIONS, calculateDistance };"],"mappings":"AAAA,MAAMA,oBAAoB,GAAG,CAAC,MAAM,EAAE,aAAa,EAAE,QAAQ,EAAE,cAAc,EAAE,OAAO,CAAC;AACvF,MAAMC,eAAe,GAAG,CAAC,MAAM,EAAE,UAAU,EAAE,KAAK,EAAE,WAAW,EAAE,OAAO,CAAC;AAEzE,OAAO,MAAMC,kBAAkB,GAAIC,KAAK,IAAK;EAC3C,MAAMC,gBAAgB,GAAGJ,oBAAoB,CAACK,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAGP,oBAAoB,CAACQ,MAAM,CAAC,CAAC;EACtG,MAAMC,WAAW,GAAGR,eAAe,CAACI,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAGN,eAAe,CAACO,MAAM,CAAC,CAAC;EAEvF,OAAO;IACLE,UAAU,EAAEN,gBAAgB;IAC5BO,KAAK,EAAEF,WAAW;IAClBN,KAAK,EAAEA;EACT,CAAC;AACH,CAAC;AAED,OAAO,MAAMS,oBAAoB,GAAIC,QAAQ,IAAK;EAChD,MAAMC,KAAK,GAAG,EAAE;EAEhB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,QAAQ,EAAEE,CAAC,EAAE,EAAE;IACjC,MAAMZ,KAAK,GAAIY,CAAC,GAAG,CAAC,GAAI,CAAC,CAAC,CAAC;IAC3BD,KAAK,CAACE,IAAI,CAACd,kBAAkB,CAACC,KAAK,CAAC,CAAC;EACvC;EAEA,OAAOW,KAAK;AACd,CAAC;AAED,OAAO,MAAMG,sBAAsB,GAAGA,CAACP,UAAU,EAAEC,KAAK,KAAK;EAC3D,MAAMO,eAAe,GAAGlB,oBAAoB,CAACmB,OAAO,CAACT,UAAU,CAAC;EAChE,MAAMU,UAAU,GAAGnB,eAAe,CAACkB,OAAO,CAACR,KAAK,CAAC;;EAEjD;EACA,OAAO;IACLU,CAAC,EAAEH,eAAe;IAClBI,CAAC,EAAEF;EACL,CAAC;AACH,CAAC;AAED,MAAMG,wBAAwB,GAAIC,IAAI,IAAK;EACzC,MAAMC,UAAU,GAAGR,sBAAsB,CAACO,IAAI,CAACd,UAAU,EAAEc,IAAI,CAACb,KAAK,CAAC;EAEtE,IAAIa,IAAI,CAACrB,KAAK,KAAK,CAAC,EAAE;IACpB;IACA,OAAO;MACLkB,CAAC,EAAEI,UAAU,CAACJ,CAAC;MACfC,CAAC,EAAEG,UAAU,CAACH;IAChB,CAAC;EACH,CAAC,MAAM;IACL;IACA;IACA,OAAO;MACLD,CAAC,EAAEI,UAAU,CAACJ,CAAC;MACfC,CAAC,EAAE,CAAC,GAAGG,UAAU,CAACH,CAAC,CAAE;IACvB,CAAC;EACH;AACF,CAAC;AAED,MAAMI,iBAAiB,GAAGA,CAACC,KAAK,EAAEC,KAAK,KAAK;EAC1C,MAAMC,OAAO,GAAGN,wBAAwB,CAACI,KAAK,CAAC;EAC/C,MAAMG,OAAO,GAAGP,wBAAwB,CAACK,KAAK,CAAC;;EAE/C;EACA,MAAMG,EAAE,GAAGF,OAAO,CAACR,CAAC,GAAGS,OAAO,CAACT,CAAC;EAChC,MAAMW,EAAE,GAAGH,OAAO,CAACP,CAAC,GAAGQ,OAAO,CAACR,CAAC;EAChC,OAAOjB,IAAI,CAAC4B,IAAI,CAACF,EAAE,GAAGA,EAAE,GAAGC,EAAE,GAAGA,EAAE,CAAC;AACrC,CAAC;AAED,MAAME,eAAe,GAAGA,CAACP,KAAK,EAAEC,KAAK,EAAEO,WAAW,EAAEC,WAAW,KAAK;EAClE,MAAMC,QAAQ,GAAGX,iBAAiB,CAACC,KAAK,EAAEC,KAAK,CAAC;EAChD,OAAOS,QAAQ,IAAIF,WAAW,IAAIE,QAAQ,IAAID,WAAW;AAC3D,CAAC;AAED,OAAO,MAAME,gCAAgC,GAAGA,CAACzB,QAAQ,EAAEsB,WAAW,GAAG,CAAC,EAAEC,WAAW,GAAGG,QAAQ,KAAK;EACrG,MAAMzB,KAAK,GAAG,EAAE;EAChB,MAAM0B,WAAW,GAAG,IAAI,CAAC,CAAC;;EAE1B,KAAK,IAAIzB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,QAAQ,EAAEE,CAAC,EAAE,EAAE;IACjC,MAAMZ,KAAK,GAAIY,CAAC,GAAG,CAAC,GAAI,CAAC;IACzB,IAAI0B,OAAO,GAAG,IAAI;IAClB,IAAIC,QAAQ,GAAG,CAAC;;IAEhB;IACA,IAAI3B,CAAC,KAAK,CAAC,EAAE;MACX0B,OAAO,GAAGvC,kBAAkB,CAACC,KAAK,CAAC;IACrC,CAAC,MAAM;MACL;MACA,OAAOuC,QAAQ,GAAGF,WAAW,EAAE;QAC7B,MAAMG,aAAa,GAAGzC,kBAAkB,CAACC,KAAK,CAAC;QAC/C,MAAMyC,YAAY,GAAG9B,KAAK,CAACC,CAAC,GAAG,CAAC,CAAC;QAEjC,IAAImB,eAAe,CAACS,aAAa,EAAEC,YAAY,EAAET,WAAW,EAAEC,WAAW,CAAC,EAAE;UAC1EK,OAAO,GAAGE,aAAa;UACvB;QACF;QACAD,QAAQ,EAAE;MACZ;;MAEA;MACA,IAAI,CAACD,OAAO,EAAE;QACZ,OAAO,IAAI;MACb;IACF;IAEA3B,KAAK,CAACE,IAAI,CAACyB,OAAO,CAAC;EACrB;EAEA,OAAO3B,KAAK;AACd,CAAC;AAED,SAASd,oBAAoB,EAAEC,eAAe,EAAEyB,iBAAiB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}