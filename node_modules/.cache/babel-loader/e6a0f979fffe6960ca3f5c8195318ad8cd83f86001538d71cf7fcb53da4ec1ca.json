{"ast":null,"code":"const HORIZONTAL_POSITIONS=['Left','Center Left','Center','Center Right','Right'];const DEPTH_POSITIONS=['Back','Mid Back','Mid','Mid Front','Front'];export const generateRandomShot=space=>{const randomHorizontal=HORIZONTAL_POSITIONS[Math.floor(Math.random()*HORIZONTAL_POSITIONS.length)];const randomDepth=DEPTH_POSITIONS[Math.floor(Math.random()*DEPTH_POSITIONS.length)];return{horizontal:randomHorizontal,depth:randomDepth,space:space};};export const generateShotSequence=numShots=>{const shots=[];for(let i=0;i<numShots;i++){const space=i%2+1;// Alternates between 1 and 2\nshots.push(generateRandomShot(space));}return shots;};export const getPositionCoordinates=(horizontal,depth)=>{const horizontalIndex=HORIZONTAL_POSITIONS.indexOf(horizontal);const depthIndex=DEPTH_POSITIONS.indexOf(depth);// Convert to grid coordinates (0-4 for both x and y)\nreturn{x:horizontalIndex,y:depthIndex};};const getContinuousCoordinates=shot=>{const baseCoords=getPositionCoordinates(shot.horizontal,shot.depth);if(shot.space===1){// Space 1: x=0-4, y=0-4 (Back=0, Front=4)\nreturn{x:baseCoords.x,y:baseCoords.y};}else{// Space 2: x=0-4, y=5-9 (Front=5, Back=9)\n// Front of Space 2 connects to Front of Space 1\nreturn{x:baseCoords.x,y:9-baseCoords.y// Flip and offset: Back(0)→9, Front(4)→5\n};}};const calculateDistance=(shot1,shot2)=>{const coords1=getContinuousCoordinates(shot1);const coords2=getContinuousCoordinates(shot2);// Euclidean distance in continuous field\nconst dx=coords1.x-coords2.x;const dy=coords1.y-coords2.y;return Math.sqrt(dx*dx+dy*dy);};const isValidDistance=(shot1,shot2,minDistance,maxDistance)=>{const distance=calculateDistance(shot1,shot2);return distance>=minDistance&&distance<=maxDistance;};const getValidShotsWithinDistance=(previousShot,targetSpace,minDistance,maxDistance)=>{const validShots=[];// Check all possible positions in the target space\nfor(const horizontal of HORIZONTAL_POSITIONS){for(const depth of DEPTH_POSITIONS){const candidateShot={horizontal,depth,space:targetSpace};const distance=calculateDistance(previousShot,candidateShot);if(distance>=minDistance&&distance<=maxDistance){validShots.push(candidateShot);}}}return validShots;};export const generateShotSequenceWithDistance=function(numShots){let minDistance=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;let maxDistance=arguments.length>2&&arguments[2]!==undefined?arguments[2]:Infinity;const maxRetries=10;// Try multiple times with different starting positions\nfor(let retry=0;retry<maxRetries;retry++){const shots=[];let success=true;for(let i=0;i<numShots;i++){const space=i%2+1;// For the first shot, no distance constraint needed\nif(i===0){shots.push(generateRandomShot(space));}else{// Get all valid shots within distance constraints\nconst validShots=getValidShotsWithinDistance(shots[i-1],space,minDistance,maxDistance);// If no valid shots exist, this attempt failed\nif(validShots.length===0){success=false;break;}// Randomly select from valid shots\nconst randomIndex=Math.floor(Math.random()*validShots.length);shots.push(validShots[randomIndex]);}}// If we successfully generated all shots, return them\nif(success){return shots;}}// If all retries failed, return null\nreturn null;};export{HORIZONTAL_POSITIONS,DEPTH_POSITIONS,calculateDistance,getContinuousCoordinates};","map":{"version":3,"names":["HORIZONTAL_POSITIONS","DEPTH_POSITIONS","generateRandomShot","space","randomHorizontal","Math","floor","random","length","randomDepth","horizontal","depth","generateShotSequence","numShots","shots","i","push","getPositionCoordinates","horizontalIndex","indexOf","depthIndex","x","y","getContinuousCoordinates","shot","baseCoords","calculateDistance","shot1","shot2","coords1","coords2","dx","dy","sqrt","isValidDistance","minDistance","maxDistance","distance","getValidShotsWithinDistance","previousShot","targetSpace","validShots","candidateShot","generateShotSequenceWithDistance","arguments","undefined","Infinity","maxRetries","retry","success","randomIndex"],"sources":["/home/jasonho/projects/shot-sequence/src/utils/shotGenerators.js"],"sourcesContent":["const HORIZONTAL_POSITIONS = ['Left', 'Center Left', 'Center', 'Center Right', 'Right'];\nconst DEPTH_POSITIONS = ['Back', 'Mid Back', 'Mid', 'Mid Front', 'Front'];\n\nexport const generateRandomShot = (space) => {\n  const randomHorizontal = HORIZONTAL_POSITIONS[Math.floor(Math.random() * HORIZONTAL_POSITIONS.length)];\n  const randomDepth = DEPTH_POSITIONS[Math.floor(Math.random() * DEPTH_POSITIONS.length)];\n  \n  return {\n    horizontal: randomHorizontal,\n    depth: randomDepth,\n    space: space\n  };\n};\n\nexport const generateShotSequence = (numShots) => {\n  const shots = [];\n  \n  for (let i = 0; i < numShots; i++) {\n    const space = (i % 2) + 1; // Alternates between 1 and 2\n    shots.push(generateRandomShot(space));\n  }\n  \n  return shots;\n};\n\nexport const getPositionCoordinates = (horizontal, depth) => {\n  const horizontalIndex = HORIZONTAL_POSITIONS.indexOf(horizontal);\n  const depthIndex = DEPTH_POSITIONS.indexOf(depth);\n  \n  // Convert to grid coordinates (0-4 for both x and y)\n  return {\n    x: horizontalIndex,\n    y: depthIndex\n  };\n};\n\nconst getContinuousCoordinates = (shot) => {\n  const baseCoords = getPositionCoordinates(shot.horizontal, shot.depth);\n  \n  if (shot.space === 1) {\n    // Space 1: x=0-4, y=0-4 (Back=0, Front=4)\n    return {\n      x: baseCoords.x,\n      y: baseCoords.y\n    };\n  } else {\n    // Space 2: x=0-4, y=5-9 (Front=5, Back=9)\n    // Front of Space 2 connects to Front of Space 1\n    return {\n      x: baseCoords.x,\n      y: 9 - baseCoords.y  // Flip and offset: Back(0)→9, Front(4)→5\n    };\n  }\n};\n\nconst calculateDistance = (shot1, shot2) => {\n  const coords1 = getContinuousCoordinates(shot1);\n  const coords2 = getContinuousCoordinates(shot2);\n  \n  // Euclidean distance in continuous field\n  const dx = coords1.x - coords2.x;\n  const dy = coords1.y - coords2.y;\n  return Math.sqrt(dx * dx + dy * dy);\n};\n\nconst isValidDistance = (shot1, shot2, minDistance, maxDistance) => {\n  const distance = calculateDistance(shot1, shot2);\n  return distance >= minDistance && distance <= maxDistance;\n};\n\nconst getValidShotsWithinDistance = (previousShot, targetSpace, minDistance, maxDistance) => {\n  const validShots = [];\n  \n  // Check all possible positions in the target space\n  for (const horizontal of HORIZONTAL_POSITIONS) {\n    for (const depth of DEPTH_POSITIONS) {\n      const candidateShot = { horizontal, depth, space: targetSpace };\n      const distance = calculateDistance(previousShot, candidateShot);\n      \n      if (distance >= minDistance && distance <= maxDistance) {\n        validShots.push(candidateShot);\n      }\n    }\n  }\n  \n  return validShots;\n};\n\nexport const generateShotSequenceWithDistance = (numShots, minDistance = 0, maxDistance = Infinity) => {\n  const maxRetries = 10; // Try multiple times with different starting positions\n  \n  for (let retry = 0; retry < maxRetries; retry++) {\n    const shots = [];\n    let success = true;\n    \n    for (let i = 0; i < numShots; i++) {\n      const space = (i % 2) + 1;\n      \n      // For the first shot, no distance constraint needed\n      if (i === 0) {\n        shots.push(generateRandomShot(space));\n      } else {\n        // Get all valid shots within distance constraints\n        const validShots = getValidShotsWithinDistance(shots[i - 1], space, minDistance, maxDistance);\n        \n        // If no valid shots exist, this attempt failed\n        if (validShots.length === 0) {\n          success = false;\n          break;\n        }\n        \n        // Randomly select from valid shots\n        const randomIndex = Math.floor(Math.random() * validShots.length);\n        shots.push(validShots[randomIndex]);\n      }\n    }\n    \n    // If we successfully generated all shots, return them\n    if (success) {\n      return shots;\n    }\n  }\n  \n  // If all retries failed, return null\n  return null;\n};\n\nexport { HORIZONTAL_POSITIONS, DEPTH_POSITIONS, calculateDistance, getContinuousCoordinates };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}